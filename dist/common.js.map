{"version":3,"file":"common.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AChGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAxBA;AAAA;AAAA;;AA4BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AANA;AAAA;AAQA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AA3CA;AAAA;AAAA;;AA8CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AA5JA;AAAA;AAAA;;AA+JA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAxCA;AAAA;AAAA;;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://eco-viz-mini/._src_config_index.ts","webpack://eco-viz-mini/._src_utils_api.ts","webpack://eco-viz-mini/._src_utils_auth.ts"],"sourcesContent":["// 小程序环境配置\nexport const config = {\n  // API 配置 - 强制使用开发环境\n  api: {\n    baseUrl: 'http://192.168.199.153:3000' // 强制使用开发环境URL\n  },\n\n  // Logto 配置 - 使用新创建的小程序应用\n  logto: {\n    endpoint: 'https://login.eboard.apps.aigrohub.com',\n    appId: 'avmoloeby2yvj8bi6mwse', // 使用环境变量中的 App ID\n    apiResource: 'https://ynsq.eboard.apps.aigrohub.com/api',\n    redirectUri: 'http://192.168.199.153:3000/api/auth/mini-callback' // 使用后端API回调\n  },\n\n  // 微信小程序配置\n  weapp: {\n    appId: 'wxa250ac138790e179'\n  }\n}\n\nexport default config\n","import Taro from '@tarojs/taro'\nimport config from '../config'\nimport { navigateToWebViewLoginSimple } from './auth'\n\n// 请求拦截器\nconst request = (url: string, options: RequestInit = {}) => {\n  const token = Taro.getStorageSync('logto_token')\n  \n  return new Promise((resolve, reject) => {\n    Taro.request({\n      url: `${config.api.baseUrl}${url}`,\n      method: options.method as any || 'GET',\n      header: {\n        'Content-Type': 'application/json',\n        ...(token && { 'Authorization': `Bearer ${token}` }),\n        ...options.headers\n      },\n      data: options.body ? JSON.parse(options.body as string) : undefined,\n      success: (res) => {\n        if (res.statusCode === 401) {\n          // Token 过期，清除本地存储并跳转登录\n          Taro.removeStorageSync('logto_token')\n          navigateToWebViewLoginSimple(); // 不能加await！\n          reject(new Error('登录已过期'))\n          return\n        }\n        \n        if (res.statusCode >= 200 && res.statusCode < 300) {\n          resolve(res.data)\n        } else {\n          reject(new Error(`请求失败: ${res.statusCode}`))\n        }\n      },\n      fail: (error) => {\n        reject(error)\n      }\n    })\n  })\n}\n\n// API 方法封装\nexport const api = {\n  // 获取用户信息（小程序专用接口）\n  getUserInfo: () => request('/api/mini/my-account'),\n  \n  // 小程序：获取分组（当前用户可见）\n  getMiniGroups: () => request('/api/mini/groups'),\n\n  // 小程序：获取设备列表（分页）\n  getMiniDevices: (params: { groupId?: string | number, page?: number, pageSize?: number, keyword?: string, search?: string, devicetype?: string }) => {\n    const query = new URLSearchParams()\n    if (params.groupId !== undefined) query.set('groupId', String(params.groupId))\n    if (params.page !== undefined) query.set('page', String(params.page))\n    if (params.pageSize !== undefined) query.set('pageSize', String(params.pageSize))\n    // search 参数优先级更高，与后台保持一致\n    if (params.search) {\n      query.set('search', params.search)\n    } else if (params.keyword) {\n      query.set('keyword', params.keyword)\n    }\n    if (params.devicetype) {\n      query.set('devicetype', params.devicetype)\n    }\n    const qs = query.toString() ? `?${query.toString()}` : ''\n    return request(`/api/mini/devices${qs}`)\n  },\n  \n  // 获取设备详情（保留原有 Web 端接口，如后续需要）\n  getDeviceDetail: (id: number) => request(`/api/devices/${id}`),\n  \n  // 获取设备参数\n  getDeviceParameters: (id: number) => request(`/api/devices/${id}/parameters`),\n  \n  // 根据参数名称列表获取参数详情\n  getParametersInfo: (parameterNames: string[]) => {\n    const params = new URLSearchParams()\n    params.set('parameters', parameterNames.join(','))\n    return request(`/api/parameters?${params.toString()}`)\n  },\n  \n  // 获取设备历史数据\n  getDeviceHistoryData: (id: number, params: { parameters: string, startDate: string, endDate: string }) => {\n    const query = new URLSearchParams()\n    query.set('parameters', params.parameters)\n    query.set('startDate', params.startDate)\n    query.set('endDate', params.endDate)\n    return request(`/api/devices/${id}/history-data?${query.toString()}`)\n  },\n  \n  // 获取设备数据\n  getDeviceData: (id: number, params?: any) => {\n    const queryString = params ? `?${new URLSearchParams(params).toString()}` : ''\n    return request(`/api/devices/${id}/et-data${queryString}`)\n  }\n}\n\nexport default api\n","import Taro from '@tarojs/taro'\nimport config from '../config'\n\n// 生成随机字符串 - 使用更安全的字符集\nconst generateRandomString = (length: number) => {\n  const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_' // 移除 . 和 ~ 避免 URL 编码问题\n  let result = ''\n  for (let i = 0; i < length; i++) {\n    result += charset.charAt(Math.floor(Math.random() * charset.length))\n  }\n  return result\n}\n\n// 小程序环境的 Base64 编码实现\nconst base64Encode = (str: string) => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  let result = ''\n  let i = 0\n  \n  while (i < str.length) {\n    const a = str.charCodeAt(i++)\n    const b = i < str.length ? str.charCodeAt(i++) : 0\n    const c = i < str.length ? str.charCodeAt(i++) : 0\n    \n    const bitmap = (a << 16) | (b << 8) | c\n    \n    result += chars.charAt((bitmap >> 18) & 63)\n    result += chars.charAt((bitmap >> 12) & 63)\n    result += i - 2 < str.length ? chars.charAt((bitmap >> 6) & 63) : '='\n    result += i - 1 < str.length ? chars.charAt(bitmap & 63) : '='\n  }\n  \n  return result\n}\n\n// 生成 code_challenge (SHA256 + Base64URL)\nconst generateCodeChallenge = async (codeVerifier: string) => {\n  try {\n    // 在小程序环境中，我们使用 Web Crypto API 生成真正的 SHA256\n    if (typeof crypto !== 'undefined' && crypto.subtle) {\n      const encoder = new TextEncoder()\n      const data = encoder.encode(codeVerifier)\n      const hash = await crypto.subtle.digest('SHA-256', data)\n      \n      // 转换为 Base64URL\n      const base64 = base64Encode(String.fromCharCode(...new Uint8Array(hash)))\n      const base64url = base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n      \n      // SHA256的Base64URL编码应该是43个字符\n      return base64url\n    } else {\n      throw new Error('Web Crypto API not available')\n    }\n  } catch (error) {\n    console.warn('SHA256 failed, using fallback:', error)\n    // 降级方案：使用简单的 Base64 编码（仅用于测试）\n    const base64 = base64Encode(codeVerifier)\n    const base64url = base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n    return base64url\n  }\n}\n\n\n\n// WebView 登录 - 使用简化的会话ID方案\nexport const navigateToWebViewLoginSimple = async () => {\n  try {\n    console.log('🚀 请求后端生成PKCE参数...')\n    \n    // 调用后端API生成PKCE参数\n    const response = await Taro.request({\n      url: `${config.api.baseUrl}/api/auth/mini-pkce`,\n      method: 'GET',\n      header: {\n        'Content-Type': 'application/json'\n      }\n    })\n    \n    if (response.statusCode === 200 && response.data.code === 0) {\n      const pkceData = response.data.data\n      console.log('✅ PKCE参数获取成功:', pkceData.loginUrl.substring(0, 100) + '...')\n      \n      // 存储 code_verifier 用于后续的 token 交换\n      Taro.setStorageSync('pkce_code_verifier', pkceData.codeVerifier)\n      \n      // 跳转到WebView页面\n      const encodedUrl = encodeURIComponent(pkceData.loginUrl)\n      const encodedCodeVerifier = encodeURIComponent(pkceData.codeVerifier)\n      \n      // 加强 debug 日志和报错显示\n      Taro.navigateTo({\n        url: `/pages/webview/index?url=${encodedUrl}&code_verifier=${encodedCodeVerifier}`,\n        success: () => console.log('WebView 登录页面跳转成功'),\n        fail: (err) => {\n          console.error('WebView 登录页面跳转失败', err)\n          Taro.showToast({ title: '跳转登录页失败', icon: 'none' })\n        }\n      })\n    } else {\n      throw new Error(response.data.message || 'PKCE参数生成失败')\n    }\n  } catch (error) {\n    console.error('❌ WebView登录失败:', error)\n    Taro.showToast({\n      title: '登录失败，请重试',\n      icon: 'none'\n    })\n  }\n}\n\n\n// 登录成功后处理（服务端代理模式）\nexport const handleLoginSuccess = async (tempToken: string) => {\n  try {\n    console.log('🔄 处理临时 token（JWT解码）...')\n    console.log('Temp token length:', tempToken ? tempToken.length : 0)\n\n    // ========== JWT Token 解码 ==========\n    // JWT 格式: header.payload.signature\n    // 我们只需要解码 payload 部分来获取数据\n    const decodeJWT = (jwt: string): any => {\n      try {\n        const parts = jwt.split('.')\n        if (parts.length !== 3) {\n          throw new Error('无效的 JWT 格式')\n        }\n\n        // 解码 payload（第二个部分）\n        const payload = parts[1]\n        \n        // Base64URL 解码\n        const safeBase64UrlDecodeToString = (input: string): string => {\n          // 将 Base64URL 转为标准 Base64，并补齐 '='\n          const base64 = input.replace(/-/g, '+').replace(/_/g, '/')\n          const padLen = (4 - (base64.length % 4)) % 4\n          const padded = base64 + '='.repeat(padLen)\n\n          const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n          const rev: Record<string, number> = {}\n          for (let i = 0; i < alphabet.length; i++) rev[alphabet[i]] = i\n\n          const bytes: Array<number> = []\n          let buffer = 0\n          let bits = 0\n          for (let i = 0; i < padded.length; i++) {\n            const c = padded[i]\n            if (c === '=') break\n            const val = rev[c]\n            if (val === undefined) continue\n            buffer = (buffer << 6) | val\n            bits += 6\n            if (bits >= 8) {\n              bits -= 8\n              const byte = (buffer >> bits) & 0xff\n              bytes.push(byte)\n              buffer = buffer & ((1 << bits) - 1)\n            }\n          }\n\n          // UTF-8 解码\n          let out = ''\n          for (let i = 0; i < bytes.length; ) {\n            const b0 = bytes[i++]\n            if (b0 < 0x80) {\n              out += String.fromCharCode(b0)\n            } else if (b0 >= 0xc0 && b0 < 0xe0) {\n              const b1 = bytes[i++]\n              out += String.fromCharCode(((b0 & 0x1f) << 6) | (b1 & 0x3f))\n            } else if (b0 >= 0xe0 && b0 < 0xf0) {\n              const b1 = bytes[i++]\n              const b2 = bytes[i++]\n              out += String.fromCharCode(\n                ((b0 & 0x0f) << 12) | ((b1 & 0x3f) << 6) | (b2 & 0x3f)\n              )\n            } else {\n              // 超过 BMP 的字符（4 字节），转为代理对\n              const b1 = bytes[i++]\n              const b2 = bytes[i++]\n              const b3 = bytes[i++]\n              let codePoint =\n                ((b0 & 0x07) << 18) | ((b1 & 0x3f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f)\n              codePoint -= 0x10000\n              out += String.fromCharCode(0xd800 + ((codePoint >> 10) & 0x3ff))\n              out += String.fromCharCode(0xdc00 + (codePoint & 0x3ff))\n            }\n          }\n          return out\n        }\n\n        const decodedStr = safeBase64UrlDecodeToString(payload)\n        const decoded = JSON.parse(decodedStr)\n\n        // 验证过期时间（exp 字段，单位：秒）\n        if (decoded.exp) {\n          const now = Math.floor(Date.now() / 1000)\n          if (decoded.exp < now) {\n            throw new Error('临时 token 已过期')\n          }\n        }\n\n        return decoded\n      } catch (error) {\n        console.error('JWT 解码失败:', error)\n        throw new Error('无效的临时凭证格式')\n      }\n    }\n\n    // 解码 JWT token\n    const decoded = decodeJWT(tempToken)\n\n    if (!decoded || !decoded.access_token) {\n      throw new Error('无效的临时凭证')\n    }\n\n    const accessToken = decoded.access_token\n    const expiresIn = decoded.expires_in || 3600\n\n    // 存储用户 access_token（与后端统一）\n    Taro.setStorageSync('logto_token', accessToken)\n    Taro.setStorageSync('token_expires_in', expiresIn)\n    Taro.setStorageSync('login_timestamp', Date.now())\n\n    // 清除临时登录状态\n    Taro.removeStorageSync('pkce_code_verifier')\n\n    // 尝试通过后端 API 获取用户信息（而不是直接调用 Logto）\n    try {\n      const meResp = await Taro.request({\n        url: `${config.api.baseUrl}/api/me/data`,\n        method: 'GET',\n        header: getAuthHeaders()\n      })\n\n      if (meResp.statusCode === 200 && meResp.data && meResp.data.code === 0) {\n        const userData = meResp.data.data\n        if (userData?.user) {\n          const userInfo = userData.user\n          Taro.setStorageSync('user_info', userInfo)\n          // 缓存 userId 用于请求透传\n          if (userInfo.id) {\n            Taro.setStorageSync('user_id', userInfo.id)\n          }\n          console.log('✅ 用户信息已获取并缓存')\n        }\n      }\n    } catch (e) {\n      console.warn('⚠️ 获取用户信息失败（可忽略，不影响登录）:', e)\n      // 不影响登录流程，继续执行\n    }\n\n    console.log('✅ 登录成功，令牌已存储')\n    Taro.showToast({ title: '登录成功', icon: 'success' })\n\n    // 跳转到首页\n    setTimeout(() => {\n      Taro.redirectTo({ \n        url: '/pages/home/index',\n        fail: () => {\n          // 如果 redirectTo 失败，使用 reLaunch\n          Taro.reLaunch({ url: '/pages/home/index' })\n        }\n      })\n    }, 1000)\n  } catch (error) {\n    console.error('❌ 处理临时 token 失败:', error)\n    const errorMsg = error instanceof Error ? error.message : '登录验证失败'\n    Taro.showToast({ title: errorMsg, icon: 'none' })\n  }\n}\n\n\n// 检查登录状态\nexport const checkLoginStatus = async () => {\n  try {\n    // 检查 logto_token（WebView登录）\n    const accessToken = Taro.getStorageSync('logto_token')\n    const loginTimestamp = Taro.getStorageSync('login_timestamp')\n    const expiresIn = Taro.getStorageSync('token_expires_in')\n    \n    if (!accessToken || !loginTimestamp || !expiresIn) {\n      console.log('❌ 登录状态检查失败：缺少必要信息')\n      return { isLoggedIn: false }\n    }\n    \n    // 检查 token 是否过期\n    const now = Date.now()\n    const tokenAge = now - loginTimestamp\n    const maxAge = expiresIn * 1000 // 转换为毫秒\n    \n    if (tokenAge > maxAge) {\n      console.log('❌ Token 已过期，清除登录状态')\n      clearLoginData()\n      return { isLoggedIn: false }\n    }\n    \n    // 验证 token 是否有效\n    const userInfo = Taro.getStorageSync('user_info')\n    if (!userInfo) {\n      console.log('❌ 缺少用户信息')\n      return { isLoggedIn: false }\n    }\n    \n    console.log('✅ 登录状态检查成功')\n    return {\n      isLoggedIn: true,\n      user: userInfo,\n      access_token: accessToken\n    }\n  } catch (error) {\n    console.error('❌ 检查登录状态失败:', error)\n    return { isLoggedIn: false }\n  }\n}\n\n// 清除登录数据\nexport const clearLoginData = () => {\n  try {\n    // 清除所有登录相关的存储\n    Taro.removeStorageSync('logto_token')\n    Taro.removeStorageSync('user_info')\n    Taro.removeStorageSync('user_id')\n    Taro.removeStorageSync('token_expires_in')\n    Taro.removeStorageSync('login_timestamp')\n    Taro.removeStorageSync('pkce_code_verifier')\n    console.log('✅ 登录数据已清除')\n  } catch (error) {\n    console.error('❌ 清除登录数据失败:', error)\n  }\n}\n\n// 获取带认证头的请求配置\nexport const getAuthHeaders = () => {\n  // 仅使用用户 access_token（logto_token）\n  const accessToken = Taro.getStorageSync('logto_token')\n  return {\n    'Authorization': `Bearer ${accessToken}`,\n    'Content-Type': 'application/json'\n  }\n}\n\nexport default {\n  checkLoginStatus,\n  navigateToWebViewLoginSimple,\n  handleLoginSuccess,\n  clearLoginData,\n  getAuthHeaders\n}\n"],"names":[],"sourceRoot":""}